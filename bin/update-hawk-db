#!/usr/bin/env node

"use strict";

var _ = require("lodash");
var async = require("async");
var mongoose = require("mongoose");
var CronJob = require("cron").CronJob;
var argv = require("yargs")
    .default("stop", true)
    .default("create", true)
    .default("cron", true)
    .argv;

// Config
var logger = require("../config/logger");
var AWSConfig = require("../config/aws");
var mongoConfig = require("../config/mongo");

// Models
var Artist = require("../models/Artist");
var DatabaseUpdate = require("../models/DatabaseUpdate");

// Services
var EC2Service = require("../services/EC2Service");
var SNSService = require("../services/SNSService");
var MusicBrainzService = require("../services/MusicBrainzService");

// The stats for the last update run.
var lastUpdateStats;

// Stats for the current update run
var currentStats;

// Ignore artists with these names
var ignore = [
  "Various Artists",
  "[unknown]"
];

// Connect to Mongo
mongoose.connect(mongoConfig.uri, mongoConfig.options);

/**
 * Log the progress of the database update as % of artists completed.
 */
function logProgress() {
  logger.info("Updated %s out of %s artists (%s\%)", currentStats.artistsUpdated, currentStats.totalArtists, 
      Math.floor(currentStats.artistsUpdated / currentStats.totalArtists * 100));
}

/**
 * Fetch the releases for an artist from the MusicBrainz database, then update the Hawk database with any new releases.
 */
var updateArtist = function(artist, callback) {
  if (ignore.indexOf(artist.name) > -1) {
    logger.info("Skipping artist %s", artist.name);
    return callback(null);
  }

  MusicBrainzService.getReleasesForArtist(artist._id, function(err, releases) {
    artist.releases = releases;

    Artist.findById(artist._id, function(err, artistModel) {
      if (err) {
        logger.error("Could not get artist %s", artist.name);
        return callback(err);
      }

      if (artistModel) {
        // The number of releases from the MusicBrainz DB minus the number of releases that existed in both the Hawk
        // and the MusicBrainz DB is the number of new releases.
        var oldReleases = artistModel.releases.map(function(release) { return release._id; });
        var newReleases = releases.map(function(release) { return release._id; });
        currentStats.newReleases += (newReleases.length - _.intersection(oldReleases, newReleases).length);
        currentStats.totalReleases += newReleases.length;
      } else {
        currentStats.newArtists++;
        currentStats.newReleases += releases.length;
        currentStats.totalReleases += releases.length;
      }

      Artist.update({ _id: artist._id }, artist, { upsert: true }, function(err) {
        if (err) {
          logger.error("Failed to save artist %s", artist.name, err);
          callback(err);
        } else {
          logger.debug("Saved artist %s with %d releases", artist.name, releases.length);
          currentStats.artistsUpdated++;
          callback(null);
        }
      });
    });
  });
};

/**
 * Fetch the artists from the MusicBrainz database then update the releases for each one.
 */
var getArtistsAndUpdate = function(callback) {
  logger.info("Updating Hawk database");

  // Interval object for the % complete logging
  var progress;

  async.waterfall([
    function(callback) {
      MusicBrainzService.getArtists(callback);
    },
    function(artists, callback) {
      logger.info("Found %d artists in MusicBrainz database", artists.length);
      currentStats.totalArtists = artists.length;
      progress = setInterval(logProgress, 10000);

      async.eachLimit(artists, 40, updateArtist, function(err) {
        if (err) {
          logger.error("Failed to update all artists", err);
          callback(err);
        } else {
          logger.info("Successfully updated all artists");
          callback(null);
        }
      });
    },
    function(callback) {
      clearInterval(progress);
      logProgress();
      logger.info("Found %d new artists", currentStats.newArtists);
      logger.info("Found %d new releases", currentStats.newReleases);

      // Send an SNS notification with some stats about the update e.g. how many new artists/releases
      SNSService.sendDatabaseUpdateMessage("Finished Updating Hawk DB", JSON.stringify(currentStats, null, "\t"), callback, true);
    }
  ], function (err) {
    if (err) {
      callback(err);
    } else {
      callback(null);
    }
  });
};

/**
 * Business time.
 */
function updateHawkDB(exitOnFinish) {
  currentStats = new DatabaseUpdate();

  async.series({
    startMusicBrainz: function(callback) {
      EC2Service.startInstance(AWSConfig.EC2.musicBrainz.instanceId, callback);
    },
    waitUntilMusicBrainzRunning: function(callback) {
      EC2Service.waitForInstanceStatus(AWSConfig.EC2.musicBrainz.instanceId, "instanceRunning", callback);
    },
    getLastUpdateStats: function(callback) {
      DatabaseUpdate.find().limit(1).sort("-updateDate").exec(function(err, stats) {
        if (err) {
          callback(err);
        } else {
          lastUpdateStats = stats[0];
          callback(null);
        }
      });
    },
    createMusicBrainzDB: function(callback) {
      var lastUpdateVersion = lastUpdateStats ? lastUpdateStats.version : "";
      logger.info("Last database update was %s", lastUpdateVersion);
      
      if (!argv.create) {
        logger.info("Skipping creating a new MusicBrainz database, using last update %s", lastUpdateVersion);
        currentStats.version = lastUpdateVersion;
        return callback(null);
      }

      MusicBrainzService.createDatabase(lastUpdateVersion, function(err, version) {
        if (err) {
          callback(err);
        } else {
          currentStats.version = version;
          callback(null);
        }
      });
    },
    updateArtists: function(callback) {
      getArtistsAndUpdate(callback);
    },
    saveUpdateStats: function(callback) {
      currentStats.save(function(err) {
        if (err) {
          callback(err);
        } else {
          callback(null);
        }
      });
    }
  }, function(err) {
    var exitCode = err ? 1 : 0;

    async.parallel({
      sendError: function(callback) {
        if (err) {
          logger.error(err.message);
          SNSService.sendDatabaseUpdateMessage("Failed to Update Hawk DB", err.message, callback, true);
        } else {
          logger.info("Successfully updated Hawk DB");
          callback(null);
        }
      },
      stopMusicBrainz: function(callback) {
        if (argv.stop) {
          EC2Service.stopInstance(AWSConfig.EC2.musicBrainz.instanceId, callback, true);
        } else {
          logger.info("Skipping stop MusicBrainz database");
          callback(null);
        }
      }
    }, function() {
      logger.info("Finished with exit code %d", exitCode);
      if (exitOnFinish) {
        process.exit(exitCode);
      }
    });
  });
}

if (argv.cron) {
  new CronJob({
    cronTime: "00 */30 * * * *", // 1PM UTC == 12AM AEDT
    onTick: function() {
      updateHawkDB(false);
    }
  }).start();
} else {
  updateHawkDB(true);
}
